#!/usr/bin/env ruby
# tt - a 9term-compatible terminal in Ruby/Tk.

require 'tk'
require 'pty'

Thread.abort_on_exception = true

case RUBY_PLATFORM
when /linux/
  TIOCSWINSZ = 0x5414
else
  TIOCSWINSZ = nil
end

# XXX dynamic font changes (at least fixed/proportional)
def set_font(font)
  if $text
    $text.font = font
  end
  @font = font
  @font_height = TkFont.metrics(font, "linespace")
  @font_width = TkFont.measure(font, "0")
end
DEFAULT_FONT = '-misc-fixed-bold-r-normal--15-140-75-75-c-90-iso8859-1'  # 9x15bold
set_font DEFAULT_FONT

$root = TkRoot.new { title "tt" }

yscroll = TkScrollbar.new($root) {
  pack 'side' => 'left', 'fill' => 'y'
}

p @font
# XXX provide text via socket?
$text = text = TkText.new($root) {
  yscrollbar yscroll
  # XXX default size
  height 25
  width 80
  font DEFAULT_FONT
  tabstyle 'wordprocessor'
  pack 'fill' => 'both', 'expand' => 'yes'
}

scroll = TkVariable.new
scroll.value = "1"

ENV["TERM"] = "9term"
input, output, pid = PTY.spawn('/usr/bin/rc')
#input.set_encoding "UTF-8", "UTF-8"
#output.set_encoding "UTF-8", "UTF-8"

# hack
def fix_utf8(buf)
  buf.force_encoding("UTF-8")
  buf.encode!("UTF-16", :invalid => :replace, :undef => :replace)
  buf.encode!("UTF-8")
  buf
end

Thread.new {
  begin
    while buf = input.readpartial(4096)
      buf = fix_utf8(buf).delete("\r")
      
      # XXX handle \r properly, clear to beginning of line? (also for C-u)
      out = ""
      buf.each_char { |char|
        if char == "\b"
          if out.empty?
            text.delete('end - 2 chars')
          else
            out.chop!
          end
        else
          out << char
        end
      }

      out.gsub!(/\033\];(.*?)\007/) { 
        $root.title = $1
        ""
      }

      text.insert 'end', out
      
      # XXX proper autoscroll, output $LINES lines
      if scroll.value == "1"
        text.yview_moveto 1
      end
    end
  rescue Errno::EIO
    # XXX too late now anyway?
    exit
  end
}


text.bind("KeyPress") { |o|
  case o.keysym
  when "Next", "Prior", "Up", "Down", "Left", "Right"
    # XXX good idea left/right?
    # PASSTHRU, no callback_break!
  when "Home"
    text.yview_moveto 0
    text.mark_set('insert', '1.0')
    Tk.callback_break
  when "End"
    text.yview_moveto 1
    text.mark_set('insert', 'end')
    Tk.callback_break
  else

    if text.index('end') == text.index('insert + 1 chars')
      output.write o.char
      Tk.callback_break
    elsif o.char == ?\C-w
      # XXX skip whitespace first
      text.delete('insert - 1c wordstart', 'insert')
    elsif o.char == ?\C-u
      text.delete('insert linestart', 'insert')
    else
      #PASSTHRU, no callback_break!
    end
  end

}

text.bind("Button-2") { |o|
  sel = TkSelection.get(:type => "UTF8_STRING")  rescue ""

  text.mark_set('insert', 'end')

  output.write sel

  text.mark_set('insert', 'end')

  Tk.callback_break
}

menu = TkMenu.new($root) { tearoff false }
menu.add :command, :label => "fwd",
  :command => lambda {
  sel = text.get('sel.first', 'sel.last')  rescue break
  if match = text.tksearch(sel, 'sel.last', 'end')
    text.tag_remove 'sel', 'sel.first', 'sel.last'
    text.tag_add 'sel', match, "#{match} + #{sel.size} chars"
    text.mark_set('insert', 'sel.first')
  end
}
menu.add :command, :label => "bwd",
  :command => lambda {
  sel = text.get('sel.first', 'sel.last')  rescue break
  if match = text.tksearch(['backwards'], sel, 'sel.first', '1.0')
    text.tag_remove 'sel', 'sel.first', 'sel.last'
    text.tag_add 'sel', match, "#{match} + #{sel.size} chars"
    text.mark_set('insert', 'sel.first')
  end
}

menu.add :command, :label => "cut"
menu.add :command, :label => "paste"
menu.add :command, :label => "snarf"
# XXX should be a checkbutton?
menu.add :command, :label => "font",
:command => lambda {
  if @font == DEFAULT_FONT
    set_font '-*-lucida-medium-r-*-*-12-*-*-*-*-*-*-*'
  else
    set_font DEFAULT_FONT
  end
}
menu.add :command, :label => "send",
  :command => lambda {
  sel = text.get('sel.first', 'sel.last') + "\n"  rescue break
  text.mark_set('insert', 'end')
  output.write sel
  text.mark_set('insert', 'end')
}
menu.add :command, :label => "clear",
  :command => lambda { text.delete('1.0', 'end') }
menu.add :checkbutton, :label => "scroll", :variable => scroll
%w(One Two Three).each {|i| }
$root.bind '3', proc{|x,y| menu.popup(x,y)}, "[expr %X - 10] [expr %Y - 10]"

if TIOCSWINSZ
  pw = ph = 0
  $root.bind('Configure') { |o|
    # XXX slow down
    unless pw == o.width && ph == o.height
      pw = o.width
      ph = o.height
      w = text.winfo_width / @font_width
      h = text.winfo_height / @font_height
      output.ioctl(TIOCSWINSZ, [h, w, ph, pw].pack('SSSS'))
    end
  }
end

text.focus

Tk.mainloop
